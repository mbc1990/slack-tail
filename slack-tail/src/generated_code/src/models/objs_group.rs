/* 
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * OpenAPI spec version: 1.5.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ObjsGroup {
  #[serde(rename = "created")]
  created: i32,
  #[serde(rename = "creator")]
  creator: ::models::DefsUserId,
  #[serde(rename = "id")]
  id: ::models::DefsGroupId,
  #[serde(rename = "is_archived")]
  is_archived: Option<bool>,
  #[serde(rename = "is_deleted")]
  is_deleted: Option<bool>,
  #[serde(rename = "is_group")]
  is_group: bool,
  #[serde(rename = "is_moved")]
  is_moved: Option<i32>,
  #[serde(rename = "is_mpim")]
  is_mpim: Option<bool>,
  #[serde(rename = "is_open")]
  is_open: Option<bool>,
  #[serde(rename = "is_pending_ext_shared")]
  is_pending_ext_shared: Option<bool>,
  #[serde(rename = "is_read_only")]
  is_read_only: Option<bool>,
  #[serde(rename = "is_thread_only")]
  is_thread_only: Option<bool>,
  #[serde(rename = "last_read")]
  last_read: Option<::models::DefsTs>,
  #[serde(rename = "latest")]
  latest: Option<Value>,
  #[serde(rename = "members")]
  members: Option<Vec<::models::DefsUserId>>,
  #[serde(rename = "name")]
  name: String,
  #[serde(rename = "name_normalized")]
  name_normalized: String,
  #[serde(rename = "num_members")]
  num_members: Option<i32>,
  #[serde(rename = "parent_group")]
  parent_group: Option<::models::DefsGroupId>,
  #[serde(rename = "priority")]
  priority: Option<f32>,
  #[serde(rename = "purpose")]
  purpose: ::models::ObjsChannelPurpose,
  #[serde(rename = "topic")]
  topic: ::models::ObjsChannelPurpose,
  #[serde(rename = "unread_count")]
  unread_count: Option<i32>,
  #[serde(rename = "unread_count_display")]
  unread_count_display: Option<i32>
}

impl ObjsGroup {
  pub fn new(created: i32, creator: ::models::DefsUserId, id: ::models::DefsGroupId, is_group: bool, name: String, name_normalized: String, purpose: ::models::ObjsChannelPurpose, topic: ::models::ObjsChannelPurpose) -> ObjsGroup {
    ObjsGroup {
      created: created,
      creator: creator,
      id: id,
      is_archived: None,
      is_deleted: None,
      is_group: is_group,
      is_moved: None,
      is_mpim: None,
      is_open: None,
      is_pending_ext_shared: None,
      is_read_only: None,
      is_thread_only: None,
      last_read: None,
      latest: None,
      members: None,
      name: name,
      name_normalized: name_normalized,
      num_members: None,
      parent_group: None,
      priority: None,
      purpose: purpose,
      topic: topic,
      unread_count: None,
      unread_count_display: None
    }
  }

  pub fn set_created(&mut self, created: i32) {
    self.created = created;
  }

  pub fn with_created(mut self, created: i32) -> ObjsGroup {
    self.created = created;
    self
  }

  pub fn created(&self) -> &i32 {
    &self.created
  }


  pub fn set_creator(&mut self, creator: ::models::DefsUserId) {
    self.creator = creator;
  }

  pub fn with_creator(mut self, creator: ::models::DefsUserId) -> ObjsGroup {
    self.creator = creator;
    self
  }

  pub fn creator(&self) -> &::models::DefsUserId {
    &self.creator
  }


  pub fn set_id(&mut self, id: ::models::DefsGroupId) {
    self.id = id;
  }

  pub fn with_id(mut self, id: ::models::DefsGroupId) -> ObjsGroup {
    self.id = id;
    self
  }

  pub fn id(&self) -> &::models::DefsGroupId {
    &self.id
  }


  pub fn set_is_archived(&mut self, is_archived: bool) {
    self.is_archived = Some(is_archived);
  }

  pub fn with_is_archived(mut self, is_archived: bool) -> ObjsGroup {
    self.is_archived = Some(is_archived);
    self
  }

  pub fn is_archived(&self) -> Option<&bool> {
    self.is_archived.as_ref()
  }

  pub fn reset_is_archived(&mut self) {
    self.is_archived = None;
  }

  pub fn set_is_deleted(&mut self, is_deleted: bool) {
    self.is_deleted = Some(is_deleted);
  }

  pub fn with_is_deleted(mut self, is_deleted: bool) -> ObjsGroup {
    self.is_deleted = Some(is_deleted);
    self
  }

  pub fn is_deleted(&self) -> Option<&bool> {
    self.is_deleted.as_ref()
  }

  pub fn reset_is_deleted(&mut self) {
    self.is_deleted = None;
  }

  pub fn set_is_group(&mut self, is_group: bool) {
    self.is_group = is_group;
  }

  pub fn with_is_group(mut self, is_group: bool) -> ObjsGroup {
    self.is_group = is_group;
    self
  }

  pub fn is_group(&self) -> &bool {
    &self.is_group
  }


  pub fn set_is_moved(&mut self, is_moved: i32) {
    self.is_moved = Some(is_moved);
  }

  pub fn with_is_moved(mut self, is_moved: i32) -> ObjsGroup {
    self.is_moved = Some(is_moved);
    self
  }

  pub fn is_moved(&self) -> Option<&i32> {
    self.is_moved.as_ref()
  }

  pub fn reset_is_moved(&mut self) {
    self.is_moved = None;
  }

  pub fn set_is_mpim(&mut self, is_mpim: bool) {
    self.is_mpim = Some(is_mpim);
  }

  pub fn with_is_mpim(mut self, is_mpim: bool) -> ObjsGroup {
    self.is_mpim = Some(is_mpim);
    self
  }

  pub fn is_mpim(&self) -> Option<&bool> {
    self.is_mpim.as_ref()
  }

  pub fn reset_is_mpim(&mut self) {
    self.is_mpim = None;
  }

  pub fn set_is_open(&mut self, is_open: bool) {
    self.is_open = Some(is_open);
  }

  pub fn with_is_open(mut self, is_open: bool) -> ObjsGroup {
    self.is_open = Some(is_open);
    self
  }

  pub fn is_open(&self) -> Option<&bool> {
    self.is_open.as_ref()
  }

  pub fn reset_is_open(&mut self) {
    self.is_open = None;
  }

  pub fn set_is_pending_ext_shared(&mut self, is_pending_ext_shared: bool) {
    self.is_pending_ext_shared = Some(is_pending_ext_shared);
  }

  pub fn with_is_pending_ext_shared(mut self, is_pending_ext_shared: bool) -> ObjsGroup {
    self.is_pending_ext_shared = Some(is_pending_ext_shared);
    self
  }

  pub fn is_pending_ext_shared(&self) -> Option<&bool> {
    self.is_pending_ext_shared.as_ref()
  }

  pub fn reset_is_pending_ext_shared(&mut self) {
    self.is_pending_ext_shared = None;
  }

  pub fn set_is_read_only(&mut self, is_read_only: bool) {
    self.is_read_only = Some(is_read_only);
  }

  pub fn with_is_read_only(mut self, is_read_only: bool) -> ObjsGroup {
    self.is_read_only = Some(is_read_only);
    self
  }

  pub fn is_read_only(&self) -> Option<&bool> {
    self.is_read_only.as_ref()
  }

  pub fn reset_is_read_only(&mut self) {
    self.is_read_only = None;
  }

  pub fn set_is_thread_only(&mut self, is_thread_only: bool) {
    self.is_thread_only = Some(is_thread_only);
  }

  pub fn with_is_thread_only(mut self, is_thread_only: bool) -> ObjsGroup {
    self.is_thread_only = Some(is_thread_only);
    self
  }

  pub fn is_thread_only(&self) -> Option<&bool> {
    self.is_thread_only.as_ref()
  }

  pub fn reset_is_thread_only(&mut self) {
    self.is_thread_only = None;
  }

  pub fn set_last_read(&mut self, last_read: ::models::DefsTs) {
    self.last_read = Some(last_read);
  }

  pub fn with_last_read(mut self, last_read: ::models::DefsTs) -> ObjsGroup {
    self.last_read = Some(last_read);
    self
  }

  pub fn last_read(&self) -> Option<&::models::DefsTs> {
    self.last_read.as_ref()
  }

  pub fn reset_last_read(&mut self) {
    self.last_read = None;
  }

  pub fn set_latest(&mut self, latest: Value) {
    self.latest = Some(latest);
  }

  pub fn with_latest(mut self, latest: Value) -> ObjsGroup {
    self.latest = Some(latest);
    self
  }

  pub fn latest(&self) -> Option<&Value> {
    self.latest.as_ref()
  }

  pub fn reset_latest(&mut self) {
    self.latest = None;
  }

  pub fn set_members(&mut self, members: Vec<::models::DefsUserId>) {
    self.members = Some(members);
  }

  pub fn with_members(mut self, members: Vec<::models::DefsUserId>) -> ObjsGroup {
    self.members = Some(members);
    self
  }

  pub fn members(&self) -> Option<&Vec<::models::DefsUserId>> {
    self.members.as_ref()
  }

  pub fn reset_members(&mut self) {
    self.members = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> ObjsGroup {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_name_normalized(&mut self, name_normalized: String) {
    self.name_normalized = name_normalized;
  }

  pub fn with_name_normalized(mut self, name_normalized: String) -> ObjsGroup {
    self.name_normalized = name_normalized;
    self
  }

  pub fn name_normalized(&self) -> &String {
    &self.name_normalized
  }


  pub fn set_num_members(&mut self, num_members: i32) {
    self.num_members = Some(num_members);
  }

  pub fn with_num_members(mut self, num_members: i32) -> ObjsGroup {
    self.num_members = Some(num_members);
    self
  }

  pub fn num_members(&self) -> Option<&i32> {
    self.num_members.as_ref()
  }

  pub fn reset_num_members(&mut self) {
    self.num_members = None;
  }

  pub fn set_parent_group(&mut self, parent_group: ::models::DefsGroupId) {
    self.parent_group = Some(parent_group);
  }

  pub fn with_parent_group(mut self, parent_group: ::models::DefsGroupId) -> ObjsGroup {
    self.parent_group = Some(parent_group);
    self
  }

  pub fn parent_group(&self) -> Option<&::models::DefsGroupId> {
    self.parent_group.as_ref()
  }

  pub fn reset_parent_group(&mut self) {
    self.parent_group = None;
  }

  pub fn set_priority(&mut self, priority: f32) {
    self.priority = Some(priority);
  }

  pub fn with_priority(mut self, priority: f32) -> ObjsGroup {
    self.priority = Some(priority);
    self
  }

  pub fn priority(&self) -> Option<&f32> {
    self.priority.as_ref()
  }

  pub fn reset_priority(&mut self) {
    self.priority = None;
  }

  pub fn set_purpose(&mut self, purpose: ::models::ObjsChannelPurpose) {
    self.purpose = purpose;
  }

  pub fn with_purpose(mut self, purpose: ::models::ObjsChannelPurpose) -> ObjsGroup {
    self.purpose = purpose;
    self
  }

  pub fn purpose(&self) -> &::models::ObjsChannelPurpose {
    &self.purpose
  }


  pub fn set_topic(&mut self, topic: ::models::ObjsChannelPurpose) {
    self.topic = topic;
  }

  pub fn with_topic(mut self, topic: ::models::ObjsChannelPurpose) -> ObjsGroup {
    self.topic = topic;
    self
  }

  pub fn topic(&self) -> &::models::ObjsChannelPurpose {
    &self.topic
  }


  pub fn set_unread_count(&mut self, unread_count: i32) {
    self.unread_count = Some(unread_count);
  }

  pub fn with_unread_count(mut self, unread_count: i32) -> ObjsGroup {
    self.unread_count = Some(unread_count);
    self
  }

  pub fn unread_count(&self) -> Option<&i32> {
    self.unread_count.as_ref()
  }

  pub fn reset_unread_count(&mut self) {
    self.unread_count = None;
  }

  pub fn set_unread_count_display(&mut self, unread_count_display: i32) {
    self.unread_count_display = Some(unread_count_display);
  }

  pub fn with_unread_count_display(mut self, unread_count_display: i32) -> ObjsGroup {
    self.unread_count_display = Some(unread_count_display);
    self
  }

  pub fn unread_count_display(&self) -> Option<&i32> {
    self.unread_count_display.as_ref()
  }

  pub fn reset_unread_count_display(&mut self) {
    self.unread_count_display = None;
  }

}



