/* 
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * OpenAPI spec version: 1.5.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ObjsTeam {
  #[serde(rename = "archived")]
  archived: Option<bool>,
  #[serde(rename = "avatar_base_url")]
  avatar_base_url: Option<String>,
  #[serde(rename = "created")]
  created: Option<i32>,
  #[serde(rename = "date_create")]
  date_create: Option<i32>,
  #[serde(rename = "deleted")]
  deleted: Option<bool>,
  #[serde(rename = "description")]
  description: Option<String>,
  #[serde(rename = "discoverable")]
  discoverable: Option<String>,
  #[serde(rename = "domain")]
  domain: String,
  #[serde(rename = "email_domain")]
  email_domain: String,
  #[serde(rename = "enterprise_id")]
  enterprise_id: Option<::models::DefsEnterpriseId>,
  #[serde(rename = "enterprise_name")]
  enterprise_name: Option<::models::DefsEnterpriseName>,
  #[serde(rename = "has_compliance_export")]
  has_compliance_export: Option<bool>,
  #[serde(rename = "icon")]
  icon: ::models::ObjsIcon,
  #[serde(rename = "id")]
  id: ::models::DefsTeam,
  #[serde(rename = "is_assigned")]
  is_assigned: Option<bool>,
  #[serde(rename = "is_enterprise")]
  is_enterprise: Option<i32>,
  #[serde(rename = "limit_ts")]
  limit_ts: Option<i32>,
  #[serde(rename = "messages_count")]
  messages_count: Option<i32>,
  #[serde(rename = "msg_edit_window_mins")]
  msg_edit_window_mins: Option<i32>,
  #[serde(rename = "name")]
  name: String,
  #[serde(rename = "over_integrations_limit")]
  over_integrations_limit: Option<bool>,
  #[serde(rename = "over_storage_limit")]
  over_storage_limit: Option<bool>,
  #[serde(rename = "plan")]
  plan: Option<String>
}

impl ObjsTeam {
  pub fn new(domain: String, email_domain: String, icon: ::models::ObjsIcon, id: ::models::DefsTeam, name: String) -> ObjsTeam {
    ObjsTeam {
      archived: None,
      avatar_base_url: None,
      created: None,
      date_create: None,
      deleted: None,
      description: None,
      discoverable: None,
      domain: domain,
      email_domain: email_domain,
      enterprise_id: None,
      enterprise_name: None,
      has_compliance_export: None,
      icon: icon,
      id: id,
      is_assigned: None,
      is_enterprise: None,
      limit_ts: None,
      messages_count: None,
      msg_edit_window_mins: None,
      name: name,
      over_integrations_limit: None,
      over_storage_limit: None,
      plan: None
    }
  }

  pub fn set_archived(&mut self, archived: bool) {
    self.archived = Some(archived);
  }

  pub fn with_archived(mut self, archived: bool) -> ObjsTeam {
    self.archived = Some(archived);
    self
  }

  pub fn archived(&self) -> Option<&bool> {
    self.archived.as_ref()
  }

  pub fn reset_archived(&mut self) {
    self.archived = None;
  }

  pub fn set_avatar_base_url(&mut self, avatar_base_url: String) {
    self.avatar_base_url = Some(avatar_base_url);
  }

  pub fn with_avatar_base_url(mut self, avatar_base_url: String) -> ObjsTeam {
    self.avatar_base_url = Some(avatar_base_url);
    self
  }

  pub fn avatar_base_url(&self) -> Option<&String> {
    self.avatar_base_url.as_ref()
  }

  pub fn reset_avatar_base_url(&mut self) {
    self.avatar_base_url = None;
  }

  pub fn set_created(&mut self, created: i32) {
    self.created = Some(created);
  }

  pub fn with_created(mut self, created: i32) -> ObjsTeam {
    self.created = Some(created);
    self
  }

  pub fn created(&self) -> Option<&i32> {
    self.created.as_ref()
  }

  pub fn reset_created(&mut self) {
    self.created = None;
  }

  pub fn set_date_create(&mut self, date_create: i32) {
    self.date_create = Some(date_create);
  }

  pub fn with_date_create(mut self, date_create: i32) -> ObjsTeam {
    self.date_create = Some(date_create);
    self
  }

  pub fn date_create(&self) -> Option<&i32> {
    self.date_create.as_ref()
  }

  pub fn reset_date_create(&mut self) {
    self.date_create = None;
  }

  pub fn set_deleted(&mut self, deleted: bool) {
    self.deleted = Some(deleted);
  }

  pub fn with_deleted(mut self, deleted: bool) -> ObjsTeam {
    self.deleted = Some(deleted);
    self
  }

  pub fn deleted(&self) -> Option<&bool> {
    self.deleted.as_ref()
  }

  pub fn reset_deleted(&mut self) {
    self.deleted = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> ObjsTeam {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_discoverable(&mut self, discoverable: String) {
    self.discoverable = Some(discoverable);
  }

  pub fn with_discoverable(mut self, discoverable: String) -> ObjsTeam {
    self.discoverable = Some(discoverable);
    self
  }

  pub fn discoverable(&self) -> Option<&String> {
    self.discoverable.as_ref()
  }

  pub fn reset_discoverable(&mut self) {
    self.discoverable = None;
  }

  pub fn set_domain(&mut self, domain: String) {
    self.domain = domain;
  }

  pub fn with_domain(mut self, domain: String) -> ObjsTeam {
    self.domain = domain;
    self
  }

  pub fn domain(&self) -> &String {
    &self.domain
  }


  pub fn set_email_domain(&mut self, email_domain: String) {
    self.email_domain = email_domain;
  }

  pub fn with_email_domain(mut self, email_domain: String) -> ObjsTeam {
    self.email_domain = email_domain;
    self
  }

  pub fn email_domain(&self) -> &String {
    &self.email_domain
  }


  pub fn set_enterprise_id(&mut self, enterprise_id: ::models::DefsEnterpriseId) {
    self.enterprise_id = Some(enterprise_id);
  }

  pub fn with_enterprise_id(mut self, enterprise_id: ::models::DefsEnterpriseId) -> ObjsTeam {
    self.enterprise_id = Some(enterprise_id);
    self
  }

  pub fn enterprise_id(&self) -> Option<&::models::DefsEnterpriseId> {
    self.enterprise_id.as_ref()
  }

  pub fn reset_enterprise_id(&mut self) {
    self.enterprise_id = None;
  }

  pub fn set_enterprise_name(&mut self, enterprise_name: ::models::DefsEnterpriseName) {
    self.enterprise_name = Some(enterprise_name);
  }

  pub fn with_enterprise_name(mut self, enterprise_name: ::models::DefsEnterpriseName) -> ObjsTeam {
    self.enterprise_name = Some(enterprise_name);
    self
  }

  pub fn enterprise_name(&self) -> Option<&::models::DefsEnterpriseName> {
    self.enterprise_name.as_ref()
  }

  pub fn reset_enterprise_name(&mut self) {
    self.enterprise_name = None;
  }

  pub fn set_has_compliance_export(&mut self, has_compliance_export: bool) {
    self.has_compliance_export = Some(has_compliance_export);
  }

  pub fn with_has_compliance_export(mut self, has_compliance_export: bool) -> ObjsTeam {
    self.has_compliance_export = Some(has_compliance_export);
    self
  }

  pub fn has_compliance_export(&self) -> Option<&bool> {
    self.has_compliance_export.as_ref()
  }

  pub fn reset_has_compliance_export(&mut self) {
    self.has_compliance_export = None;
  }

  pub fn set_icon(&mut self, icon: ::models::ObjsIcon) {
    self.icon = icon;
  }

  pub fn with_icon(mut self, icon: ::models::ObjsIcon) -> ObjsTeam {
    self.icon = icon;
    self
  }

  pub fn icon(&self) -> &::models::ObjsIcon {
    &self.icon
  }


  pub fn set_id(&mut self, id: ::models::DefsTeam) {
    self.id = id;
  }

  pub fn with_id(mut self, id: ::models::DefsTeam) -> ObjsTeam {
    self.id = id;
    self
  }

  pub fn id(&self) -> &::models::DefsTeam {
    &self.id
  }


  pub fn set_is_assigned(&mut self, is_assigned: bool) {
    self.is_assigned = Some(is_assigned);
  }

  pub fn with_is_assigned(mut self, is_assigned: bool) -> ObjsTeam {
    self.is_assigned = Some(is_assigned);
    self
  }

  pub fn is_assigned(&self) -> Option<&bool> {
    self.is_assigned.as_ref()
  }

  pub fn reset_is_assigned(&mut self) {
    self.is_assigned = None;
  }

  pub fn set_is_enterprise(&mut self, is_enterprise: i32) {
    self.is_enterprise = Some(is_enterprise);
  }

  pub fn with_is_enterprise(mut self, is_enterprise: i32) -> ObjsTeam {
    self.is_enterprise = Some(is_enterprise);
    self
  }

  pub fn is_enterprise(&self) -> Option<&i32> {
    self.is_enterprise.as_ref()
  }

  pub fn reset_is_enterprise(&mut self) {
    self.is_enterprise = None;
  }

  pub fn set_limit_ts(&mut self, limit_ts: i32) {
    self.limit_ts = Some(limit_ts);
  }

  pub fn with_limit_ts(mut self, limit_ts: i32) -> ObjsTeam {
    self.limit_ts = Some(limit_ts);
    self
  }

  pub fn limit_ts(&self) -> Option<&i32> {
    self.limit_ts.as_ref()
  }

  pub fn reset_limit_ts(&mut self) {
    self.limit_ts = None;
  }

  pub fn set_messages_count(&mut self, messages_count: i32) {
    self.messages_count = Some(messages_count);
  }

  pub fn with_messages_count(mut self, messages_count: i32) -> ObjsTeam {
    self.messages_count = Some(messages_count);
    self
  }

  pub fn messages_count(&self) -> Option<&i32> {
    self.messages_count.as_ref()
  }

  pub fn reset_messages_count(&mut self) {
    self.messages_count = None;
  }

  pub fn set_msg_edit_window_mins(&mut self, msg_edit_window_mins: i32) {
    self.msg_edit_window_mins = Some(msg_edit_window_mins);
  }

  pub fn with_msg_edit_window_mins(mut self, msg_edit_window_mins: i32) -> ObjsTeam {
    self.msg_edit_window_mins = Some(msg_edit_window_mins);
    self
  }

  pub fn msg_edit_window_mins(&self) -> Option<&i32> {
    self.msg_edit_window_mins.as_ref()
  }

  pub fn reset_msg_edit_window_mins(&mut self) {
    self.msg_edit_window_mins = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> ObjsTeam {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_over_integrations_limit(&mut self, over_integrations_limit: bool) {
    self.over_integrations_limit = Some(over_integrations_limit);
  }

  pub fn with_over_integrations_limit(mut self, over_integrations_limit: bool) -> ObjsTeam {
    self.over_integrations_limit = Some(over_integrations_limit);
    self
  }

  pub fn over_integrations_limit(&self) -> Option<&bool> {
    self.over_integrations_limit.as_ref()
  }

  pub fn reset_over_integrations_limit(&mut self) {
    self.over_integrations_limit = None;
  }

  pub fn set_over_storage_limit(&mut self, over_storage_limit: bool) {
    self.over_storage_limit = Some(over_storage_limit);
  }

  pub fn with_over_storage_limit(mut self, over_storage_limit: bool) -> ObjsTeam {
    self.over_storage_limit = Some(over_storage_limit);
    self
  }

  pub fn over_storage_limit(&self) -> Option<&bool> {
    self.over_storage_limit.as_ref()
  }

  pub fn reset_over_storage_limit(&mut self) {
    self.over_storage_limit = None;
  }

  pub fn set_plan(&mut self, plan: String) {
    self.plan = Some(plan);
  }

  pub fn with_plan(mut self, plan: String) -> ObjsTeam {
    self.plan = Some(plan);
    self
  }

  pub fn plan(&self) -> Option<&String> {
    self.plan.as_ref()
  }

  pub fn reset_plan(&mut self) {
    self.plan = None;
  }

}



