/* 
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * OpenAPI spec version: 1.5.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ObjsPaging {
  #[serde(rename = "count")]
  count: Option<i32>,
  #[serde(rename = "page")]
  page: i32,
  #[serde(rename = "pages")]
  pages: Option<i32>,
  #[serde(rename = "per_page")]
  per_page: Option<i32>,
  #[serde(rename = "spill")]
  spill: Option<i32>,
  #[serde(rename = "total")]
  total: i32
}

impl ObjsPaging {
  pub fn new(page: i32, total: i32) -> ObjsPaging {
    ObjsPaging {
      count: None,
      page: page,
      pages: None,
      per_page: None,
      spill: None,
      total: total
    }
  }

  pub fn set_count(&mut self, count: i32) {
    self.count = Some(count);
  }

  pub fn with_count(mut self, count: i32) -> ObjsPaging {
    self.count = Some(count);
    self
  }

  pub fn count(&self) -> Option<&i32> {
    self.count.as_ref()
  }

  pub fn reset_count(&mut self) {
    self.count = None;
  }

  pub fn set_page(&mut self, page: i32) {
    self.page = page;
  }

  pub fn with_page(mut self, page: i32) -> ObjsPaging {
    self.page = page;
    self
  }

  pub fn page(&self) -> &i32 {
    &self.page
  }


  pub fn set_pages(&mut self, pages: i32) {
    self.pages = Some(pages);
  }

  pub fn with_pages(mut self, pages: i32) -> ObjsPaging {
    self.pages = Some(pages);
    self
  }

  pub fn pages(&self) -> Option<&i32> {
    self.pages.as_ref()
  }

  pub fn reset_pages(&mut self) {
    self.pages = None;
  }

  pub fn set_per_page(&mut self, per_page: i32) {
    self.per_page = Some(per_page);
  }

  pub fn with_per_page(mut self, per_page: i32) -> ObjsPaging {
    self.per_page = Some(per_page);
    self
  }

  pub fn per_page(&self) -> Option<&i32> {
    self.per_page.as_ref()
  }

  pub fn reset_per_page(&mut self) {
    self.per_page = None;
  }

  pub fn set_spill(&mut self, spill: i32) {
    self.spill = Some(spill);
  }

  pub fn with_spill(mut self, spill: i32) -> ObjsPaging {
    self.spill = Some(spill);
    self
  }

  pub fn spill(&self) -> Option<&i32> {
    self.spill.as_ref()
  }

  pub fn reset_spill(&mut self) {
    self.spill = None;
  }

  pub fn set_total(&mut self, total: i32) {
    self.total = total;
  }

  pub fn with_total(mut self, total: i32) -> ObjsPaging {
    self.total = total;
    self
  }

  pub fn total(&self) -> &i32 {
    &self.total
  }


}



